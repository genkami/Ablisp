// Package env provides an environment, which is a mapping
// from variable names to their values.

import {len} from "std"

// new_env returns an empty environment.
// An environment is of the form
//     [var1, ptr1, var2, ptr2, ...]
// Where vars are variable names in Text and ptrs are pointers to objects casted as Text.
pub fun new_env(): [Text] {
    let env = [Text]
    return env
}

// env_is_invalid returns true if and only if `env` is invalid.
// Some functions that updates environments may return an invalid environment
// when it gets an error.
pub fun env_is_invalid(env: [Text]): Bool {
    return len(env) % 2 == 1
}

// env_invalid_to_err converts an invalid env into an error result.
pub fun env_invalid_to_err(env: [Text]): [Text] {
    return new_err(env[1], env[2])
}

// new_invalid_env returns an invalid env with a given reason.
fun new_invalid_env(code: Text, reason: Text): [Text] {
    return ["err", code, reason]
}

// env_define defines a new variable with the given name and value.
pub fun env_define(env: [Text], name: Text, ptr: Num): [Text] {
    let new_env = env + [name, ptr as Text]
    return new_env
}

// env_lookup returns a value (in ptr wrapped with result) of a variable.
// If there are multiple variables with the same name, it returns
// the one in the innermost scope (i.e. the one defined last).
// If there is no such variable, it returns an error result.
#[allow_absurd_cast]
pub fun env_lookup(env: [Text], name: Text): [Text] {
    let last_found_value = -1
    let i = 0
    loop {
        if len(env) <= i {
            break
        }
        if env[i] == name {
            last_found_value = env[i + 1] as Num
        }
        i += 2
    }
    if last_found_value < 0 {
        return new_err(code_undefined_variable(), "undefined: " + name)
    }
    return new_ok(last_found_value)
}

// env_set sets a variable to a given value (in ptr).
// If there are multiple variables with the same name, it modifies
// the one in the innermost scope (i.e. the one defined last).
// If there is no such variable, it returns an invalid env.
pub fun env_set(env: [Text], name: Text, ptr: Num): [Text] {
    let last_found_index = -1
    let i = 0
    loop {
        if len(env) <= i {
            break
        }
        if env[i] == name {
            last_found_index = i
        }
        i += 2
    }
    if last_found_index < 0 {
        return new_invalid_env(code_undefined_variable(), "undefined: " + name)
    }
    env[last_found_index + 1] = ptr as Text
    return env
}

// env_collect_varrefs returns all pointers to objects which are
// reachable from a given env.
#[allow_absurd_cast]
pub fun env_collect_varrefs(env: [Text]): [Num] {
    let refs = [Num]
    let i = 0
    loop {
        if len(env) <= i {
            break
        }
        let ptr = env[i + 1] as Num
        refs += [ptr]
        i += 2
    }
    return refs
}
