// Module object manages Ablisp virtual memory and every Ablisp object.
import {len} from "std"
import * from "./memory.ab"

let the_memory = [Text]

pub fun debug_clear(): Null {
    the_memory = memory_new(0)
}

pub fun debug_dump_current_memory(): [Text] {
    return the_memory
}

fun find_next_place(): Num {
    let max_objs = memory_get_max_objects(the_memory)
    let i = 0
    loop {
        if max_objs <= i {
            break
        }
        let tag = memory_get_tag(the_memory, i)
        if tag == tag_unused() {
            return i
        }
        i += 1
    }
    the_memory = memory_grow(the_memory)
    return max_objs
}

pub fun new_num(val: Num): Num {
    let i = find_next_place()
    the_memory = memory_put_num(the_memory, i, val)
    return i
}

pub fun new_text(val: Text): Num {
    let i = find_next_place()
    the_memory = memory_put_text(the_memory, i, val)
    return i
}

pub fun new_t(): Num {
    let i = find_next_place()
    the_memory = memory_put_t(the_memory, i)
    return i
}

pub fun new_nil(): Num {
    let i = find_next_place()
    the_memory = memory_put_nil(the_memory, i)
    return i
}

pub fun new_cons(car: Num, cdr: Num): Num {
    let i = find_next_place()
    the_memory = memory_put_cons(the_memory, i, car, cdr)
    return i
}

pub fun tag_of(ptr: Num): Num {
    return memory_get_tag(the_memory, ptr)
}

pub fun object_is_num(ptr: Num): Bool {
    return tag_of(ptr) == tag_num()
}

pub fun object_is_text(ptr: Num): Bool {
    return tag_of(ptr) == tag_text()
}

pub fun object_is_t(ptr: Num): Bool {
    return tag_of(ptr) == tag_t()
}

pub fun object_is_nil(ptr: Num): Bool {
    return tag_of(ptr) == tag_nil()
}

pub fun object_is_cons(ptr: Num): Bool {
    return tag_of(ptr) == tag_cons()
}

pub fun num_value(ptr: Num): Num {
    return memory_get_num(the_memory, ptr)
}

pub fun text_value(ptr: Num): Text {
    return memory_get_text(the_memory, ptr)
}

pub fun cons_car(ptr: Num): Num {
    return memory_get_cons_car(the_memory, ptr)
}

pub fun cons_cdr(ptr: Num): Num {
    return memory_get_cons_cdr(the_memory, ptr)
}

pub fun object_set_num(ptr: Num, value: Num) {
    memory_put_num(the_memory, ptr, value)
}

pub fun object_set_text(ptr: Num, value: Text) {
    memory_put_text(the_memory, ptr, value)
}

pub fun object_set_t(ptr: Num) {
    memory_put_t(the_memory, ptr)
}

pub fun object_set_nil(ptr: Num) {
    memory_put_nil(the_memory, ptr)
}

pub fun object_set_cons(ptr: Num, car: Num, cdr: Num) {
    memory_put_cons(the_memory, ptr, car, cdr)
}

pub fun cons_set_car(ptr: Num, car: Num) {
    let cdr = memory_get_cons_cdr(ptr)
    memory_put_cons(the_memory, ptr, car, cdr)
}

pub fun cons_set_cdr(ptr: Num, cdr: Num) {
    let car = memory_get_cons_car(ptr)
    memory_put_cons(the_memory, ptr, car, cdr)
}

pub fun garbage_collect(addrs: [Num]): Null {
    let referenced_objects = init_referenced_objects(memory_get_max_objects(the_memory))
    let i = 0
    loop {
        if len(addrs) <= i {
            break
        }
        let ptr = addrs[i]
        referenced_objects[ptr] = true
        i += 1
    }
    the_memory = memory_garbage_collect(the_memory, referenced_objects)
}

pub fun object_eqv(ptr1: Num, ptr2: Num): Bool {
    let tag1 = tag_of(ptr1)
    let tag2 = tag_of(ptr2)
    if tag1 == tag_num() {
        return tag2 == tag_num() and num_value(ptr1) == num_value(ptr2)
    } else if tag1 == tag_text() {
        return tag2 == tag_text() and text_value(ptr1) == text_value(ptr2)
    } else if tag1 == tag_t() {
        return tag2 == tag_t()
    } else if tag1 == tag_nil() {
        return tag2 == tag_nil()
    } else if tag1 == tag_cons() {
        return tag1 == tag2
    }
}

pub fun object_equal(ptr1: Num, ptr2: Num): Bool {
    let tag1 = tag_of(ptr1)
    let tag2 = tag_of(ptr2)
    if tag1 == tag_num() {
        return tag2 == tag_num() and num_value(ptr1) == num_value(ptr2)
    } else if tag1 == tag_text() {
        return tag2 == tag_text() and text_value(ptr1) == text_value(ptr2)
    } else if tag1 == tag_t() {
        return tag2 == tag_t()
    } else if tag1 == tag_nil() {
        return tag2 == tag_nil()
    } else if tag1 == tag_cons() {
        if tag2 != tag_cons() {
            return false
        }
        let car1 = cons_car(ptr1)
        let car2 = cons_car(ptr2)
        if not object_equal(car1, car2) {
            return false
        }
        let cdr1 = cons_cdr(ptr1)
        let cdr2 = cons_cdr(ptr2)
        if not object_equal(cdr1, cdr2) {
            return false
        }
        return true
    }
}

pub fun object_to_string(ptr: Num): Text {
    let tag = tag_of(ptr)

    if tag == tag_unused() {
        return "<unused: {ptr}>"
    }
    if tag == tag_num() {
        return "{ptr}"
    }
    if tag == tag_text() {
        return "'{ptr}'"
    }
    if tag == tag_t() {
        return "t"
    }
    if tag == tag_nil() {
        return "nil"
    }
    if tag == tag_cons() {
        let car = cons_car(ptr)
        let cdr = cons_cdr(ptr)
        let car_str = object_to_string(car)
        let cdr_str = object_to_string(cdr)
        return "(cons {car} {cdr})"
    }
    return "<invalid: {ptr} tag={tag}>"
}