// Module object manages Ablisp virtual memory and every Ablisp object.
import {len} from "std"
import * from "./memory.ab"
import * from "./callstack.ab"

let the_memory = [Text]

pub fun debug_clear(): Null {
    the_memory = memory_new(0)
}

pub fun debug_dump_current_memory(): [Text] {
    return the_memory
}

fun find_next_place(): Num {
    let max_objs = memory_get_max_objects(the_memory)
    let i = 0
    loop {
        if max_objs <= i {
            break
        }
        let tag = memory_get_tag(the_memory, i)
        if tag == tag_unused() {
            return i
        }
        i += 1
    }
    the_memory = memory_grow(the_memory)
    return max_objs
}

pub fun new_num(val: Num): Num {
    let i = find_next_place()
    the_memory = memory_put_num(the_memory, i, val)
    return i
}

pub fun new_text(val: Text): Num {
    let i = find_next_place()
    the_memory = memory_put_text(the_memory, i, val)
    return i
}

pub fun new_t(): Num {
    let i = find_next_place()
    the_memory = memory_put_t(the_memory, i)
    return i
}

pub fun new_nil(): Num {
    let i = find_next_place()
    the_memory = memory_put_nil(the_memory, i)
    return i
}

pub fun new_cons(car: Num, cdr: Num): Num {
    let i = find_next_place()
    the_memory = memory_put_cons(the_memory, i, car, cdr)
    return i
}

pub fun tag_of(ptr: Num): Num {
    return memory_get_tag(the_memory, ptr)
}

pub fun object_is_num(ptr: Num): Bool {
    return tag_of(ptr) == tag_num()
}

pub fun object_is_text(ptr: Num): Bool {
    return tag_of(ptr) == tag_text()
}

pub fun object_is_t(ptr: Num): Bool {
    return tag_of(ptr) == tag_t()
}

pub fun object_is_nil(ptr: Num): Bool {
    return tag_of(ptr) == tag_nil()
}

pub fun object_is_cons(ptr: Num): Bool {
    return tag_of(ptr) == tag_cons()
}

pub fun num_value(ptr: Num): Num {
    return memory_get_num(the_memory, ptr)
}

pub fun text_value(ptr: Num): Text {
    return memory_get_text(the_memory, ptr)
}

pub fun cons_car(ptr: Num): Num {
    return memory_get_cons_car(the_memory, ptr)
}

pub fun cons_cdr(ptr: Num): Num {
    return memory_get_cons_cdr(the_memory, ptr)
}

pub fun object_set_num(ptr: Num, value: Num): Null {
    memory_put_num(the_memory, ptr, value)
}

pub fun object_set_text(ptr: Num, value: Text): Null {
    memory_put_text(the_memory, ptr, value)
}

pub fun object_set_t(ptr: Num): Null {
    memory_put_t(the_memory, ptr)
}

pub fun object_set_nil(ptr: Num): Null {
    memory_put_nil(the_memory, ptr)
}

pub fun object_set_cons(ptr: Num, car: Num, cdr: Num): Null {
    memory_put_cons(the_memory, ptr, car, cdr)
}

pub fun cons_set_car(ptr: Num, car: Num): Null {
    let cdr = memory_get_cons_cdr(the_memory, ptr)
    memory_put_cons(the_memory, ptr, car, cdr)
}

pub fun cons_set_cdr(ptr: Num, cdr: Num): Null {
    let car = memory_get_cons_car(the_memory, ptr)
    memory_put_cons(the_memory, ptr, car, cdr)
}

pub fun garbage_collect(addrs: [Num]): Null {
    let referenced_objects = init_referenced_objects(memory_get_max_objects(the_memory))
    let i = 0
    loop {
        if len(addrs) <= i {
            break
        }
        let ptr = addrs[i]
        referenced_objects[ptr] = true
        i += 1
    }
    the_memory = memory_garbage_collect(the_memory, referenced_objects)
}

pub fun object_eqv(ptr1: Num, ptr2: Num): Bool {
    let tag1 = tag_of(ptr1)
    let tag2 = tag_of(ptr2)
    if {
        tag1 == tag_num() {
            return tag2 == tag_num() and num_value(ptr1) == num_value(ptr2)
        }
        tag1 == tag_text() {
            return tag2 == tag_text() and text_value(ptr1) == text_value(ptr2)
        }
        tag1 == tag_t() {
            return tag2 == tag_t()
        }
        tag1 == tag_nil() {
            return tag2 == tag_nil()
        }
        tag1 == tag_cons() {
            return tag1 == tag2
        }
    }
}

pub fun object_equal(ptr1: Num, ptr2: Num): Bool {
    let tag1 = tag_of(ptr1)
    let tag2 = tag_of(ptr2)
    if {
        tag1 == tag_num() {
            return tag2 == tag_num() and num_value(ptr1) == num_value(ptr2)
        }
        tag1 == tag_text() {
            return tag2 == tag_text() and text_value(ptr1) == text_value(ptr2)
        }
        tag1 == tag_t() {
            return tag2 == tag_t()
        }
        tag1 == tag_nil() {
            return tag2 == tag_nil()
        }
        tag1 == tag_cons() {
            if tag2 != tag_cons() {
                return false
            }
            let car1 = cons_car(ptr1)
            let car2 = cons_car(ptr2)
            if not object_equal(car1, car2) {
                return false
            }
            let cdr1 = cons_cdr(ptr1)
            let cdr2 = cons_cdr(ptr2)
            if not object_equal(cdr1, cdr2) {
                return false
            }
            return true
        }
    }
}

pub fun object_to_string(ptr: Num): Text {
    let close_paren = -1
    let str = ""
    let stack_base = callstack_current_sp()
    callstack_push(ptr)

    let first = true
    loop {
        if callstack_current_sp() == stack_base {
            break
        }

        ptr = callstack_pop()
        if ptr == close_paren {
            str += ")"
            continue
        }
        
        if first {
            first = false
        } else {
            str += " "
        }

        let tag = tag_of(ptr)
        if {
            tag == tag_unused() {
                str += "<unused: {ptr}>"
            }
            tag == tag_num() {
                str += "{num_value(ptr)}"
            }
            tag == tag_text() {
                str += "'{text_value(ptr)}'"
            }
            tag == tag_t() {
                str += "t"
            }
            tag == tag_nil() {
                str += "nil"
            }
            tag == tag_cons() {
                str += "(cons"
                callstack_push(close_paren)
                callstack_push(cons_cdr(ptr))
                callstack_push(cons_car(ptr))
            }
            else {
                str += "<invalid: {ptr} tag={tag}>"
            }
        }
    }
}