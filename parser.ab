// Module parser provides an S-expression parser.

import {len, chars} from "std"
import * from "./object.ab"
import * from "./callstack.ab"
import * from "./char.ab"
import * from "./error.ab"

let _buf = [Text]
let _buf_len = 0
let _next = 0
let _line = 0
let _column = 0

// init_parser initializes the global parser.
// We only provide a single, global parser because of some restrictions in Amber.
pub fun init_parser(text: Text): Null {
    _buf = chars(text)
    _buf_len = len(_buf)
    _next = 0
    _line = 0
    _column = 0
}

fun new_parse_error(reason: Text): [Text] {
        let err = new_err(code_parse_error(), reason)
        return err_add_trace(err, "line {_line}, column {_column}")
}

fun peek(n: Num): Text {
    if _buf_len <= _next + n {
        return ""
    }
    return _buf[_next + n]
}

fun consume_next(): Text {
    let next_char = _buf[_next]
    _next += 1
    _column += 1
    if next_char == "\n" {
        _line += 1
        _column = 0
    }
    return next_char
}

fun is_eof(): Bool {
    return _buf_len <= _next
}

fun is_whitespace(): Bool {
    let c = peek(0)
    return c == " " or c == "\t" or c == "\n"
}

fun is_comment_begin(): Bool {
    let c = peek(0)
    return c == ";"
}

fun consume_comment(): [Text] {
    loop {
        if is_eof() {
            return new_ok(0)
        }
        let c = consume_next()
        if c == "\n" {
            return new_ok(0)
        }
    }
}

fun is_number_begin(): Bool {
    let c0 = peek(0)
    if char_is_decimal_digit(c0) {
        return true
    }
    if not char_is_one_of(c0, ["+", "-"]) {
        return false
    }
    let c1 = peek(1)
    return char_is_decimal_digit(c1)
}

#[allow_absurd_cast]
fun consume_number(): [Text] {
    let sign = 1
    let has_explicit_sign = false
    let value = 0
    
    let c = consume_next()
    if {
        c == "+" {
            has_explicit_sign = true
        }
        c == "-" {
            has_explicit_sign = true
            sign = -1
        }
        char_is_decimal_digit(c) {
            value = c as Num
        }
        else {
            return new_parse_error("invalid number: " + c)
        }
    }
    let consumed_at_least_one_char = false
    loop {
        if is_eof() {
            break
        }
        c = peek(0)
        if not char_is_decimal_digit(c) {
            break
        }
        consume_next()
        consumed_at_least_one_char = true
        value *= 10
        value += c as Num
    }
    if has_explicit_sign and not consumed_at_least_one_char {
        return new_parse_error("invalid number format")
    }
    return new_ok(new_num(sign * value))
}

fun is_text_begin(): Bool {
    let c = peek(0)
    return c == "\""
}

fun consume_text(): [Text] {
    let text = ""
    let bs = backslash(1)
    consume_next() // first double-quote
    loop {
        if is_eof() {
            return new_parse_error("unexpected EOF while parsing text")
        }
        let c = consume_next()
        if {
            c == "\"" {
                break
            }
            c == bs {
                if is_eof() {
                    return new_parse_error("unexpected EOF while parsing escape sequence")
                }
                c = consume_next()
                if {
                    c == "\"" {
                        text += "\""
                    }
                    c == bs {
                        text += bs
                    }
                    c == "n" {
                        text += "\n"
                    }
                    else {
                        return new_parse_error("unsupported escape sequence: " + bs + c)
                    }
                }
            }
            else {
                text += c
            }
        }
    }
    return new_ok(new_text(text))
}

let symlike_head_chars = chars(
    "abcdefghijklmnopqrstuvwxyz" +
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
    "~!@$%^&*_+:.<>/?"
)

let symlike_tail_chars = symlike_head_chars + chars(
    "0123456789"
)

fun is_symlike_begin(): Bool {
    return char_is_one_of(peek(0), symlike_head_chars)
}

fun consume_symlike(): [Text] {
    let name = consume_next()
    loop {
        if is_eof() {
            break
        }
        let c = peek(0)
        if not char_is_one_of(c, symlike_tail_chars) {
            break
        }
        consume_next()
        name += c
    }
    if {
        name == "t" {
            return new_ok(new_t())
        }
        name == "nil" {
            return new_ok(new_nil())
        }
        else {
            return new_parse_error("symbol not supported")
        }
    }
}

fun is_list_begin(): Bool {
    let c = peek(0)
    return c == "("
}

fun is_list_end(): Bool {
    let c = peek(0)
    return c == ")"
}

pub fun parse_sexp(): [Text] {
    let stack_base = callstack_current_sp()
    let last_error = new_ok(0)
    let list_start = -1
    loop {
        echo "loop"
        if is_eof() {
            break
        }
        // TODO: break after consuming a single object
        if {
            is_whitespace() {
                echo "wspace"
                consume_next()
            }
            is_comment_begin() {
                echo "comment"
                let result = consume_comment()
                if result_is_err(result) {
                    last_error = result
                    break
                }
            }
            is_number_begin() {
                echo "num"
                let result = consume_number()
                if result_is_err(result) {
                    last_error = result
                    break
                }
                callstack_push(ok_val(result))
            }
            is_text_begin() {
                echo "text"
                let result = consume_text()
                if result_is_err(result) {
                    last_error = result
                    break
                }
                callstack_push(ok_val(result))
            }
            is_symlike_begin() {
                echo "symlike"
                let result = consume_symlike()
                if result_is_err(result) {
                    last_error = result
                    break
                }
                callstack_push(ok_val(result))
            }
            is_list_begin() {
                echo "list"
                consume_next()
                callstack_push(list_start)
            }
            is_list_end() {
                echo "list-end"
                consume_next()
                let list = new_nil()
                loop {
                    let top = callstack_pop()
                    if top == list_start {
                        break
                    }
                    list = new_cons(top, list)
                }
                callstack_push(list)
            }
            else {
                echo "else"
                last_error = new_parse_error("unexpected character: " + peek(0))
                break
            }
        }
    }
    if result_is_err(last_error) {
        // rewind stack
        loop {
            if callstack_current_sp() <= stack_base {
                break
            }
            callstack_pop()
        }
        return last_error
    }
    if callstack_current_sp() != stack_base + 1 {
        // rewind stack
        loop {
            if callstack_current_sp() <= stack_base {
                break
            }
            callstack_pop()
        }
        return new_parse_error("unexpected EOF")
    }
    let last_value = callstack_pop()
    if last_value < 0 {
        return new_parse_error("parenthesis not closed")
    }
    return new_ok(last_value)
}