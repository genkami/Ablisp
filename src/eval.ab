// Module eval provides an Ablisp evaluator.
import * from "./error.ab"
import * from "./object.ab"
import * from "./callstack.ab"
import * from "./native.ab"
import * from "./env.ab"

let _funcref_eval_literal = ""
let _funcref_eval_var = ""
let _funcref_eval_expr = ""

fun expr_is_literal(expr: Num): Bool {
    if object_is_num(expr) {
        return true
    }
    if object_is_text(expr) {
        return true
    }
    if object_is_t(expr) {
        return true
    }
    if object_is_nil(expr) {
        return true
    }
    return false
}

fun eval_literal_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval_literal")
        native_return(err)
        return null
    }
    let expr = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval_literal")
        native_return(err)
        return null
    }
    native_return(new_ok(expr))
    return null
}

native_track_next_funcall()
eval_literal_impl()
_funcref_eval_literal = native_get_last_funcref()

fun expr_is_var(expr: Num): Bool {
    return object_is_symbol(expr)
}

fun eval_var_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(ok_val(result_args)))
        err = err_add_trace(err, "eval_var")
        native_return(err)
        return null
    }
    let name = cons_car(args)
    args = cons_cdr(args)
    if (not object_is_symbol(name)) or (not object_is_cons(args)) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(ok_val(result_args)))
        err = err_add_trace(err, "eval_var")
        native_return(err)
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(ok_val(result_args)))
        err = err_add_trace(err, "eval_var")
        native_return(err)
        return null
    }

    let val = env_lookup(env, name)
    if result_is_err(val) {
        let err = err_add_trace(val, "eval_var")
        native_return(err)
        return null
    }
    native_return(val)
    return null
}

native_track_next_funcall()
eval_var_impl()
_funcref_eval_var = native_get_last_funcref()

pub fun eval_expr_funcref(): Text {
    return _funcref_eval_expr
}

// eval evaluates `expr` with a given `env` and returns an evaluated expression in result form.
// `context` is a string to indicate where the expr is evaluated (mainly for debug purpose).
pub fun eval_expr(expr: Num, env: Num, context: Text): [Text] {
    let args = new_nil()
    args = new_cons(new_text(context), args)
    args = new_cons(env, args)
    args = new_cons(expr, args)
    return native_call(_funcref_eval_expr, args)
}
fun eval_expr_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let expr = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if (not object_is_cons(env)) or (not object_is_cons(args)) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let context = cons_car(args)
    args = cons_cdr(args)
    if (not object_is_text(context)) or (not object_is_nil(args)) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    if expr_is_literal(expr) {
        let result_val = native_call(_funcref_eval_literal, new_cons(expr, new_nil()))
        if result_is_err(result_val) {
            native_return(err_add_trace(result_val, "eval"))
            return null
        }
        native_return(result_val)
        return null
    }
    if expr_is_var(expr) {
        let args = new_cons(env, new_nil())
        args = new_cons(expr, args)
        let result_val = native_call(_funcref_eval_var, args)
        if result_is_err(result_val) {
            native_return(err_add_trace(result_val, "eval"))
            return null
        }
        native_return(result_val)
        return null
    }
    let err = new_err(code_internal_error(), "TODO: implement special forms and function applications")
    err = err_add_trace(err, "eval")
    native_return(err)
    return null
}

native_track_next_funcall()
eval_expr_impl()
_funcref_eval_expr = native_get_last_funcref()
