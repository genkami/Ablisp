// Module eval provides an Ablisp evaluator.
import * from "./error.ab"
import * from "./object.ab"
import * from "./callstack.ab"
import * from "./native.ab"
import * from "./env.ab"

let _funcref_eval_expr = ""

// eval evaluates `expr` with a given `env` and returns an evaluated expression in result form.
// `context` is a string to indicate where the expr is evaluated (mainly for debug purpose).
pub fun eval_expr(expr: Num, env: Num, context: Text): [Text] {
    let args = new_nil()
    args = new_cons(new_text(context), args)
    args = new_cons(env, args)
    args = new_cons(expr, args)
    return native_call(_funcref_eval_expr, args)
}

fun expr_is_literal(expr: Num): Bool {
    if object_is_num(expr) {
        return true
    }
    if object_is_text(expr) {
        return true
    }
    if object_is_t(expr) {
        return true
    }
    if object_is_nil(expr) {
        return true
    }
    return false
}

fun eval_literal(expr: Num): [Text] {
    return new_ok(expr)
}

fun expr_is_var(expr: Num): Bool {
    return object_is_symbol(expr)
}

fun eval_var(expr: Num, env: Num): [Text] {
    return env_lookup(env, expr)
}

fun eval_app(expr: Num, env: Num, context: Num): [Text] {
    // TODO: evaluate args
    if not object_is_cons(expr) {
        let err = new_err(code_syntax_error(), "malformed function application: " + object_to_string(expr))
        return err
    }
    let fun_expr = cons_car(expr)
    let fun_args_exprs = cons_cdr(expr)

    let eval_fun_args = new_nil()
    let result_fun_val = eval_expr(fun_expr, env, text_value(context))
    if result_is_err(result_fun_val) {
        return result_fun_val
    }
    // TODO: evaluate args
    
    let fun_val = ok_val(result_fun_val)
    if object_is_native_fun(fun_val) {
        let fref = native_fun_funcref(fun_val)
        // TODO: pass args
        let call_result = native_call(fref, new_nil())
        return call_result
    }
    // TODO: support non-native functions
    let err = new_err(code_value_error(), object_to_string(fun_val) + " is not callable")
    return err
}

pub fun eval_expr_funcref(): Text {
    return _funcref_eval_expr
}

fun eval_expr_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let expr = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if (not object_is_cons(env)) or (not object_is_cons(args)) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let context = cons_car(args)
    args = cons_cdr(args)
    if (not object_is_text(context)) or (not object_is_nil(args)) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    if expr_is_literal(expr) {
        let result_val = eval_literal(expr)
        native_return(result_val)
        return null
    }
    if expr_is_var(expr) {
        let result_val = eval_var(expr, env)
        native_return(result_val)
        return null
    }
    let result_val = eval_app(expr, env, context)
    native_return(result_val)
    return null
}

native_track_next_funcall()
eval_expr_impl()
_funcref_eval_expr = native_get_last_funcref()
