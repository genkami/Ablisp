// Module eval provides an Ablisp evaluator.
import * from "./error.ab"
import * from "./object.ab"
import * from "./callstack.ab"
import * from "./native.ab"
import * from "./env.ab"

// new_native_fun returns a new heap-allocated pointer to a native function.
pub fun new_native_fun(funcref: Text): Num {
    let val = new_nil()
    val = new_cons(new_symbol(funcref), val)
    val = new_cons(new_symbol("#:native"), val)
    return val
}

pub fun object_is_native_fun(obj: Num): Bool {
    if not object_is_cons(obj) {
        return false
    }
    let tag = cons_car(obj)
    let fun_name_and_rest = cons_cdr(obj)
    if not object_is_symbol(tag) {
        return false
    }
    if symbol_name(tag) != "#:native" {
        return false
    }
    let fun_name = cons_car(fun_name_and_rest)
    let rest = cons_cdr(fun_name_and_rest)
    if not object_is_symbol(fun_name) {
        return false
    }
    if not object_is_nil(rest) {
        return false
    }
    return true
}

pub fun native_fun_funcref(f: Num): Text {
    let cdr = cons_cdr(f)    // (funcref)
    let cadr = cons_car(cdr) // funcref
    return symbol_name(cadr)
}

// new_special_form returns a new heap-allocated pointer to a native function.
// The difference between special forms and native functions (in Ablisp code) is
// how the evaluator deals with function calls.
// When an expression `(f a b c ...)` is given and `f` is a native function,
// the evaluator evaluates `a`, `b`, `c`, ... and passes their values to `f`.
// On the contrary, if `f` is a special form, the evaluator passes raw (or unevaluated)
// expressions of `a`, `b`, `c`, ... with the current environment and context to `f`.
//
// Example: `(f (+ 1 2) 3)`
// - If `f` is a native function whose implementation is `native_f_impl`,
//   the arguments passed to `native_f_impl` will be `(3 3)`.
// - If `f` is a special form whose implementation is `special_f_impl`,
//   the arguments passed to `special_f_impl` will be `(env ctx (+ 1 2) 3)`,
//   where `env` is the current environment, `ctx` is the name of current execution
//   context, and `(+ 1 2)` is a list of a symbol and numbers.
pub fun new_special_form(funcref: Text): Num {
    let val = new_nil()
    val = new_cons(new_symbol(funcref), val)
    val = new_cons(new_symbol("#:special"), val)
    return val
}

pub fun object_is_special_form(obj: Num): Bool {
    if not object_is_cons(obj) {
        return false
    }
    let tag = cons_car(obj)
    let fun_name_and_rest = cons_cdr(obj)
    if not object_is_symbol(tag) {
        return false
    }
    if symbol_name(tag) != "#:special" {
        return false
    }
    let fun_name = cons_car(fun_name_and_rest)
    let rest = cons_cdr(fun_name_and_rest)
    if not object_is_symbol(fun_name) {
        return false
    }
    if not object_is_nil(rest) {
        return false
    }
    return true
}

pub fun special_form_funcref(f: Num): Text {
    let cdr = cons_cdr(f)    // (funcref)
    let cadr = cons_car(cdr) // funcref
    return symbol_name(cadr)
}


let _funcref_eval_expr = ""

// eval evaluates `expr` with a given `env` and returns an evaluated expression in result form.
// `context` is a string to indicate where the expr is evaluated (mainly for debug purpose).
pub fun eval_expr(expr: Num, env: Num, context: Text): [Text] {
    let args = new_nil()
    args = new_cons(new_text(context), args)
    args = new_cons(env, args)
    args = new_cons(expr, args)
    return native_call(_funcref_eval_expr, args)
}

fun expr_is_literal(expr: Num): Bool {
    if object_is_num(expr) {
        return true
    }
    if object_is_text(expr) {
        return true
    }
    if object_is_t(expr) {
        return true
    }
    if object_is_nil(expr) {
        return true
    }
    return false
}

fun eval_literal(expr: Num): [Text] {
    return new_ok(expr)
}

fun expr_is_var(expr: Num): Bool {
    return object_is_symbol(expr)
}

fun eval_var(expr: Num, env: Num): [Text] {
    return env_lookup(env, expr)
}

fun eval_app(expr: Num, env: Num, context: Num): [Text] {
    // TODO: evaluate args
    if not object_is_cons(expr) {
        let err = new_err(code_syntax_error(), "malformed function application: " + object_to_string(expr))
        return err
    }
    let fun_expr = cons_car(expr)
    let args_exprs = cons_cdr(expr)

    let eval_fun_args = new_nil()
    let result_fun_val = eval_expr(fun_expr, env, text_value(context))
    if result_is_err(result_fun_val) {
        return result_fun_val
    }
    
    let args_val_array = [Num]
    let iter = args_exprs
    loop {
        if object_is_nil(iter) {
            break
        }
        if not object_is_cons(iter) {
            let err = new_err(code_syntax_error(), "malformed function application: " + object_to_string(expr))
            return err
        }
        let arg_expr = cons_car(iter)
        iter = cons_cdr(iter)
        let result_arg_val = eval_expr(arg_expr, env, text_value(context))
        if result_is_err(result_arg_val) {
            return result_arg_val
        }
        args_val_array = [ok_val(result_arg_val)] + args_val_array
    }

    let args_vals = new_nil()
    loop i in args_val_array {
        args_vals = new_cons(i, args_vals)
    }
    
    let fun_val = ok_val(result_fun_val)
    if object_is_native_fun(fun_val) {
        let fref = native_fun_funcref(fun_val)
        let call_result = native_call(fref, args_vals)
        if result_is_err(call_result) {
            let err = err_add_trace(call_result, "native function <" + fref + ">")
            return err
        }
        return call_result
    }
    // TODO: support non-native functions
    let err = new_err(code_value_error(), object_to_string(fun_val) + " is not callable")
    return err
}

pub fun eval_expr_funcref(): Text {
    return _funcref_eval_expr
}

fun eval_expr_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let expr = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if (not object_is_cons(env)) or (not object_is_cons(args)) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    let context = cons_car(args)
    args = cons_cdr(args)
    if (not object_is_text(context)) or (not object_is_nil(args)) {
        let err = new_err(code_invalid_argument(), "invalid argument: " + object_to_string(args))
        err = err_add_trace(err, "eval")
        native_return(err)
        return null
    }
    if expr_is_literal(expr) {
        let result_val = eval_literal(expr)
        native_return(result_val)
        return null
    }
    if expr_is_var(expr) {
        let result_val = eval_var(expr, env)
        native_return(result_val)
        return null
    }
    let result_val = eval_app(expr, env, context)
    native_return(result_val)
    return null
}

native_track_next_funcall()
eval_expr_impl()
_funcref_eval_expr = native_get_last_funcref()
