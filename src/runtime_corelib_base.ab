// Module base provides base functions for Ablisp.

import * from "./native.ab"
import * from "./error.ab"
import * from "./object.ab"
import * from "./env.ab"
import * from "./eval.ab"

let _funcref_echo = ""
let _funcref_error = ""
let _funcref_exit = ""
let _funcref_eqv = ""
let _funcref_equal = ""
let _funcref_special_quote = ""
let _funcref_cons = ""
let _funcref_car = ""
let _funcref_cdr = ""
let _funcref_set_car = ""
let _funcref_set_cdr = ""
let _funcref_special_set = ""
let _funcref_special_if = ""
let _funcref_special_let = ""

pub fun runtime_corelib_base_echo_funcref(): Text {
    return _funcref_echo
}

let _echo_desc = "Prints arguments.

```
> (echo \"Hello\")
Hello
;=> nil
> (echo \"Hello\" \"world\")
Hello
world
;=> nil
```
"

fun echo_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    loop {
        if object_is_nil(args) {
            break
        }
        if not object_is_cons(args) {
            native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
            return null
        }
        let msg = cons_car(args)
        args = cons_cdr(args)
        if not object_is_text(msg) {
            native_return(new_err(code_invalid_argument(), "argument is not text: " + object_to_string(msg)))
            return null
        }
        echo text_value(msg)
    }
    native_return(new_ok(new_nil()))
    return null
}

native_track_next_funcall()
echo_impl()
_funcref_echo = native_get_last_funcref()

pub fun runtime_corelib_base_error_funcref(): Text {
    return _funcref_error
}

let _error_desc = "Raises a user error.

```
> (error \"wrong argument!\")
Error: user_error: wrong argument!
at native function <error_impl__677_v0>
> (error \"my_error\" \"something is wrong\") ; custom error code
Error: my_error: something is wrong
at native function <error_impl__677_v0>
```
"

fun error_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let msg = cons_car(args)
    args = cons_cdr(args)
    if not object_is_text(msg) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let code = ""
    if object_is_nil(args) {
        code = code_user_error()
    }
    if object_is_cons(args) {
        let next = cons_car(args)
        if not object_is_text(next) {
            native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
            return null
        }
        code = text_value(msg)
        msg = next
        args = cons_cdr(args)
        if not object_is_nil(args) {
            native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
            return null
        }
    }
    if code == "" {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let err = new_err(code, text_value(msg))
    native_return(err)
    return null
}

native_track_next_funcall()
error_impl()
_funcref_error = native_get_last_funcref()

pub fun runtime_corelib_base_exit_funcref(): Text {
    return _funcref_exit
}

let _exit_desc = "Exits the interpreter.

```
> (exit)
;=> interpreter exits
```
"

fun exit_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let err = new_err(code_exit_interpreter(), "exit")
    native_return(err)
    return null
}

native_track_next_funcall()
exit_impl()
_funcref_exit = native_get_last_funcref()

pub fun runtime_corelib_base_eqv_funcref(): Text {
    return _funcref_eqv
}

let _eqv_desc = "Returns `t` if the arguments are the same; otherwise returns `nil`.

```
> (eqv? 1 1)
;=> t
> (eqv? 1 2)
;=> nil
> (eqv? \"foo\" 'foo)
;=> nil
> (eqv? (cons 1 2) (cons 1 2))
;=> nil
> (let ((pair (cons 1 2)))
    (eqv? pair pair))
;=> t
```
"

fun eqv_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let lhs = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let rhs = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if object_eqv(lhs, rhs) {
        native_return(new_ok(new_t()))
        return null
    }
    native_return(new_ok(new_nil()))
    return null
}

native_track_next_funcall()
eqv_impl()
_funcref_eqv = native_get_last_funcref()

pub fun runtime_corelib_base_equal_funcref(): Text {
    return _funcref_equal
}

let _equal_desc = "Returns `t` if the arguments are structually equal; otherwise returns `nil`.

```
> (equal? 1 1)
;=> t
> (equal? 1 2)
;=> nil
> (equal? \"foo\" 'foo)
;=> nil
> (equal? (cons 1 2) (cons 1 2))
;=> t
> (let ((pair (cons 1 2)))
    (equal? pair pair))
;=> t
```
```
"

fun equal_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let lhs = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let rhs = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if object_equal(lhs, rhs) {
        native_return(new_ok(new_t()))
        return null
    }
    native_return(new_ok(new_nil()))
    return null
}

native_track_next_funcall()
equal_impl()
_funcref_equal = native_get_last_funcref()

pub fun runtime_corelib_base_special_quote_funcref(): Text {
    return _funcref_special_quote
}

let _special_quote_desc = "Returns an unevaluated argument.

```
> (quote 3)
;=> 3
> (quote foo)
;=> foo
> (quote (a b c))
;=> (a b c)
> '(a b c)   ; shorthand for quote
;=> (a b c)
```
"

fun special_quote_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let ctx = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let content = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    native_return(new_ok(content))
    return null
}

native_track_next_funcall()
special_quote_impl()
_funcref_special_quote = native_get_last_funcref()

fun runtime_corelib_base_cons_funcref(): Text {
    return _funcref_cons
}

let _cons_desc = "Makes a cons-cell.

```
> (cons 1 2)
;=> (1 . 2)
> (cons 'a (cons 'b (cons 'c nil)))
;=> (a b c)
```
"

fun cons_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let car = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let cdr = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let pair = new_cons(car, cdr)
    native_return(new_ok(pair))
    return null
}

native_track_next_funcall()
cons_impl()
_funcref_cons = native_get_last_funcref()

pub fun runtime_corelib_base_car_funcref(): Text {
    return _funcref_car
}

let _car_desc = "Returns the first element of a cons-cell.

```
> (car (cons 1 2))
;=> 1
```
"

fun car_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let pair = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(pair) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let car = cons_car(pair)
    native_return(new_ok(car))
    return null
}

native_track_next_funcall()
car_impl()
_funcref_car = native_get_last_funcref()

pub fun runtime_corelib_base_cdr_funcref() {
    return _funcref_cdr
}

let _cdr_desc = "Returns the second element of a cons-cell.

```
> (cdr (cons 1 2))
;=> 2
```
"

fun cdr_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let pair = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(pair) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let cdr = cons_cdr(pair)
    native_return(new_ok(cdr))
    return null
}

native_track_next_funcall()
cdr_impl()
_funcref_cdr = native_get_last_funcref()

pub fun runtime_corelib_base_set_car_funcref(): Text {
    return _funcref_set_car
}

let _set_car_desc = "Updates the first element of a cons-cell.

```
> (let ((pair (cons 1 2)))
      (set-car! pair 999)
      pair)
;=> (999 . 2)
```
"

fun set_car_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let pair = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(pair) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let new_car = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    cons_set_car(pair, new_car)
    native_return(new_ok(new_nil()))
    return null
}

native_track_next_funcall()
set_car_impl()
_funcref_set_car = native_get_last_funcref()

pub fun runtime_corelib_base_set_cdr_funcref(): Text {
    return _funcref_set_cdr
}

let _set_cdr_desc = "Updates the second element of a cons-cell.

```
> (let ((pair (cons 1 2)))
      (set-car! pair 999)
      pair)
;=> (1 . 999)
```
"

fun set_cdr_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let pair = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(pair) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let new_cdr = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    cons_set_cdr(pair, new_cdr)
    native_return(new_ok(new_nil()))
    return null
}

native_track_next_funcall()
set_cdr_impl()
_funcref_set_cdr = native_get_last_funcref()

pub fun runtime_corelib_base_special_set_funcref(): Text {
    return _funcref_special_set
}

let _special_set_desc = "Updates the value of a variable.

```
> (let ((a 1)
        (b 2))
      (set! a 999)
      (cons a b))
;=> (999 . 2)
```
"

fun special_set_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let ctx = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let var_name = cons_car(args)
    args = cons_cdr(args)
    if not object_is_symbol(var_name) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let value = cons_car(args)
    args = cons_cdr(args)
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let result = env_set(env, var_name, value)
    if result_is_err(result) {
        native_return(result)
        return null
    }
    native_return(new_ok(new_nil()))
    return null
}

native_track_next_funcall()
special_set_impl()
_funcref_special_set = native_get_last_funcref()

pub fun runtime_corelib_base_special_if_funcref(): Text {
    return _funcref_special_if
}

let _special_if_desc = "Branches the execution of a code based on a given condition.

```
> (if t 1 2)
;=> 1
> (if nil 1 2)
;=> 2
> (if (eqv? 1 2)
      (error \"unreachable\"))
;=> nil
```
"

fun special_if_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let ctx = cons_car(args)
    args = cons_cdr(args)
    if not object_is_text(ctx) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let ctx = text_value(ctx)
    let cond_expr = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let conseq_expr = cons_car(args)
    args = cons_cdr(args)
    let alt_expr = new_nil()
    if object_is_cons(args) {
        alt_expr = cons_car(args)
        args = cons_cdr(args)
    }
    if not object_is_nil(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }

    let cond_result = eval_expr(cond_expr, env, ctx)
    if result_is_err(cond_result) {
        native_return(cond_result)
        return null
    }
    let cond_val = ok_val(cond_result)
    if object_is_nil(cond_val) {
        let alt_result = eval_expr(alt_expr, env, ctx)
        native_return(alt_result)
        return null
    }
    let conseq_result = eval_expr(conseq_expr, env, ctx)
    native_return(conseq_result)
    return null
}

native_track_next_funcall()
special_if_impl()
_funcref_special_if = native_get_last_funcref()

let _special_let_desc = "Binds values to local variables.

```
> (let ((a 1)
        (b 2))
      (+ a b))
;=> 3
```
"

fun special_let_impl(): Null {
    let result_args = native_get_args()
    if result_is_err(result_args) {
        return null
    }
    let args = ok_val(result_args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let env = cons_car(args)
    args = cons_cdr(args)
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let ctx = cons_car(args)
    args = cons_cdr(args)
    if not object_is_text(ctx) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    if not object_is_cons(args) {
        native_return(new_err(code_invalid_argument(), "invalid argument list: " + object_to_string(args)))
        return null
    }
    let ctx = text_value(ctx)

    let var_binds = cons_car(args)
    let body = cons_cdr(args)
    let body_env = env
    loop {
        if object_is_nil(var_binds) {
            break
        }
        if not object_is_cons(var_binds) {
            native_return(new_err(code_invalid_argument(), "invalid variable binding: " + object_to_string(var_binds)))
            return null
        }
        let bind = cons_car(var_binds)
        var_binds = cons_cdr(var_binds)
        if not object_is_cons(bind) {
            native_return(new_err(code_invalid_argument(), "invalid variable binding: " + object_to_string(bind)))
            return null
        }
        let var_name = cons_car(bind)
        let var_expr_and_rest = cons_cdr(bind)
        if not object_is_symbol(var_name) {
            native_return(new_err(code_invalid_argument(), "invalid variable name: " + object_to_string(var_name)))
            return null
        }
        if not object_is_cons(var_expr_and_rest) {
            native_return(new_err(code_invalid_argument(), "invalid variable binding: " + object_to_string(bind)))
            return null
        }
        let var_expr = cons_car(var_expr_and_rest)
        if not object_is_nil(cons_cdr(var_expr_and_rest)) {
            native_return(new_err(code_invalid_argument(), "invalid variable binding: " + object_to_string(bind)))
            return null
        }
        
        let var_val_result = eval_expr(var_expr, env, ctx)
        if result_is_err(var_val_result) {
            native_return(var_val_result)
            return null
        }
        let var_val = ok_val(var_val_result)
        body_env = env_define(body_env, var_name, var_val)
    }

    let last_val = new_nil()
    loop {
        if object_is_nil(body) {
            break
        }
        if not object_is_cons(body) {
            native_return(new_err(code_invalid_argument(), "invalid let body: " + object_to_string(body)))
            return null
        }
        let expr = cons_car(body)
        body = cons_cdr(body)

        let val_result = eval_expr(expr, body_env, ctx)
        if result_is_err(val_result) {
            native_return(val_result)
            return null
        }
        last_val = ok_val(val_result)
    }
    native_return(new_ok(last_val))
    return null
}

native_track_next_funcall()
special_let_impl()
_funcref_special_let = native_get_last_funcref()


// TODO:
// - eval
// - help
// - letrec
// - and/or
// - catch
// - object->string
// - begin
// - lambda

pub fun runtime_corelib_base_import(env: Num): Num {
    env = env_define(env, new_symbol("echo"), new_native_fun(_funcref_echo, _echo_desc))
    env = env_define(env, new_symbol("error"), new_native_fun(_funcref_error, _error_desc))
    env = env_define(env, new_symbol("exit"), new_native_fun(_funcref_exit, _exit_desc))
    env = env_define(env, new_symbol("eqv?"), new_native_fun(_funcref_eqv, _eqv_desc))
    env = env_define(env, new_symbol("equal?"), new_native_fun(_funcref_equal, _equal_desc))
    env = env_define(env, new_symbol("quote"), new_special_form(_funcref_special_quote, _special_quote_desc))
    env = env_define(env, new_symbol("cons"), new_native_fun(_funcref_cons, _cons_desc))
    env = env_define(env, new_symbol("car"), new_native_fun(_funcref_car, _car_desc))
    env = env_define(env, new_symbol("cdr"), new_native_fun(_funcref_cdr, _cdr_desc))
    env = env_define(env, new_symbol("set-car!"), new_native_fun(_funcref_set_car, _set_car_desc))
    env = env_define(env, new_symbol("set-cdr!"), new_native_fun(_funcref_set_cdr, _set_cdr_desc))
    env = env_define(env, new_symbol("set!"), new_special_form(_funcref_special_set, _special_set_desc))
    env = env_define(env, new_symbol("if"), new_special_form(_funcref_special_if, _special_if_desc))
    env = env_define(env, new_symbol("let"), new_special_form(_funcref_special_let, _special_let_desc))
    return env
}
